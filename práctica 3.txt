1 - 
#= en Object: Responde si el receptor y el argumento representan el mismo objeto. Se puede redefinir en cualquier subclase. En su declaración invoca el #==.
#== en ProtoObject: Primitivo. Responde si el receptor y el argumento son los mismos objeto (tiene el mismo puntero de objeto). No se redefine el mensaje == en cualquier otra clase! Esencial. No hay búsqueda. No se puede anular en ninguna subclase.

Que un método esté en el protocolo private implicaría que solo son accesibles desde la clase que los define.

La implimentacion de initialize es vacía. Las subclases pueden redefinir este método para realizar inicializaciones en la creación de instancias. 

Flechas hacia arriba indican que ese mensaje está definido en su clase padre, y hacia abajo, que está definido en una de sus subclases.

2 - 
Object subclass: #Document
	instanceVariableNames: 'title body'
	classVariableNames: ''
	package: 'Document'
  
#title
  ^ title.
  
#title: aTitle
  title := aTitle.
  
#body
  ^ body.

#body: aBody
  body := aBody.

#size
  "retorna el tamaño del documento que es la suma del tamaño del título, el
  tamaño del body y el overhead del documento que siempre es el 10% del body"

  ^ self body size + self title size + (self body size * 0.1).

#addLine: aLine
  "agrega (concatena) al body la linea aLine"
	self body: self body, aLine.

Método de clase
#titled: aString
  "Retorna una nueva instancia de Document, cuyo título es aString"

  ^ self new title: aString;
		body:''.

a. doc es una instancia de la clase Document.
b. es de la clase Float.
c. devuelve la clase a la que pertenece la instancia doc. Devuelve Document.
d. la línea 8 evalúa si la clase de la instancia doc es Document.

3 - |nrb rab|
nrb = NonRechargeableBattery new.
nrb consume: 70. "La bateria queda en 30"
nrb consume: 35. "Imprime 'Bateria descargada', la bateria queda en 30"

rab := RechargeableAlkalineBattery new.
rab consume: 70. "La bateria queda en 30"
rab consume: 35. "Imprime 'Recharging alkaline battery...', la bateria queda en 100"

4 - Object subclass: #Profile
	instanceVariableNames: 'name likes posts karma'
	classVariableNames: ''
	package: 'ProfileAndKarma'

#name: aName
 name:= aName.

#name
 ^name.

#likes: aNumber
 likes:= aNumber.
 
#likes
 ^likes.

#posts: aNumber
 posts:= aNumber.

#posts
 ^posts.

#karma: aNumber
 karma:= aNumber.

#karma
 ^karma.

#like
  self likes: self likes + 1.

#post
 self posts: self posts + 1.

#initialize
	^self name: ' '; posts: 0; likes: 0; karma: 0.

Profile class>> newProfile: aName
^self new
name: aName;
posts: 0;
likes: 0;
karma: 0;
yourself. 

#calcKarma
|aux|
aux:= (self posts // self likes) asInteger.
(aux between: 31 and: 50)
ifTrue: [ self karma: self karma + 2 ].
(aux > 51)
ifTrue: [ self karma: self karma + 3 ].
self posts: 0; likes: 0.

-------EN PLAYGROUND------------------------
user:= Profile newProfile: 'Pepe'.
user name.
user posts.
user likes.
user karma.
user like.
user post.
user calcKarma. 

5 - 
Profile subclass: #Gold
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'ProfileAndKarma'
	
Profile subclass: #Silver
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'RedSoc'
	
Profile>> #calcKarma
	  ^ self subclassResponsibility
	  
Gold>> #calcKarma
	|aux|
	aux:= (posts * likes / Float halfPi) asInteger.
	(aux between: 31 and: 50)
	ifTrue: [ self karma: self karma + 2 ].
	(aux > 51)
	ifTrue: [ self karma: self karma + 3 ].
	self posts: 0; likes: 0.
Silver>> #calcKarma
	|aux|
	aux:= (posts * likes / Float pi) asInteger.
	(aux between: 31 and: 50)
	ifTrue: [ self karma: self karma + 2 ].
	(aux > 51)
	ifTrue: [ self karma: self karma + 3 ].
	self posts: 0; likes: 0.
	
-------EN PLAYGROUND------------------------
userA:= Gold new.
userA posts.
userA likes.
userA karma.
userA like.
userA post.
userA calcKarma. 

userB:= Silver new.
userB posts.
userB likes.
userB karma.
userB like.
userB post.
userB calcKarma.

1. ¿Qué modificaciones o extensiones debe hacer a la resolución del ejercicio 4?
Se deben agregar las clase Gold y Siver, extendidas de usuario, y modificar el método #calcKarma, para que lo realicen directamente las subclases de Profile.
2. ¿Qué comportamiento tienen en común los usuarios Gold y Silver?
El propio de Profile.
3. La superclase de ambos usuarios, ¿puede instanciarse?
Si, podría porque tiene su método de clase y su inicialize, pero no podría calcular el Karma.
4. En el caso en que no pueda instanciarse, ¿cuál es la manera en Smalltalk de definir una clase de ese tipo?
